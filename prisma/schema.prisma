// Unified Prisma schema supporting both SQLite (development) and PostgreSQL (production)
// 
// This schema is designed to work with both databases with minimal differences.
// The actual provider is set at runtime based on your DATABASE_URL format:
//   - file:./dev.db → SQLite
//   - postgresql://... → PostgreSQL
//
// For development (SQLite):
//   DATABASE_URL="file:./dev.db"
//   Use: npm run prisma:migrate:dev
//
// For production (PostgreSQL):
//   DATABASE_URL="postgresql://user:password@localhost:5432/dbname"
//   Use: npm run prisma:migrate:deploy
//
// Note: By default, this schema is configured for SQLite (development).
// For production deployment, the provider should be changed to "postgresql"
// via environment-specific schema files or build scripts.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// NextAuth core models (Prisma Adapter)
model User {
  id            String   @id @default(cuid())
  name          String?
  email         String?  @unique
  emailVerified DateTime?
  image         String?
  passwordHash  String?  // For email/password authentication
  isSuperAdmin  Boolean  @default(false) // Platform-level administrator

  // Account status for approval workflow
  accountStatus     AccountStatus @default(PENDING)
  statusChangedAt   DateTime?
  statusChangedBy   String?       // SuperAdmin userId who changed status
  rejectionReason   String?
  
  // Store request information (filled during registration)
  businessName        String?
  businessDescription String?
  businessCategory    String?
  phoneNumber         String?
  
  // Approval tracking
  approvedAt        DateTime?
  approvedBy        String?       // SuperAdmin userId who approved

  // Multi-tenancy relations
  memberships   Membership[]
  projectMembers ProjectMember[]
  storeStaff    StoreStaff[] // Store-level role assignments
  customer      Customer?     // E-commerce customer profile
  inventoryLogs InventoryLog[] @relation("InventoryUserLogs")
  auditLogs     AuditLog[]     @relation("AuditUserLogs")
  notifications Notification[] @relation("UserNotifications")
  
  // Platform activity relations
  activitiesPerformed PlatformActivity[] @relation("PlatformActivityActor")
  activitiesReceived  PlatformActivity[] @relation("PlatformActivityTarget")
  
  // Store request relations
  storeRequests       StoreRequest[]     @relation("UserStoreRequests")
  reviewedStoreRequests StoreRequest[]   @relation("StoreRequestReviewer")

  accounts      Account[]
  sessions      Session[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// Account status for user approval workflow
enum AccountStatus {
  PENDING     // Awaiting Super Admin review
  APPROVED    // Can have store created
  REJECTED    // Application denied
  SUSPENDED   // Temporarily disabled
  DELETED     // Soft deleted
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Multi-tenant models
model Organization {
  id          String        @id @default(cuid())
  name        String
  slug        String        @unique
  image       String?

  memberships Membership[]
  projects    Project[]
  store       Store?        // E-commerce store for this organization

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model Membership {
  id             String        @id @default(cuid())
  userId         String
  organizationId String
  role           Role          @default(MEMBER)

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@unique([userId, organizationId])
}

enum Role {
  // Platform level
  SUPER_ADMIN
  
  // Organization level
  OWNER
  ADMIN
  MEMBER
  VIEWER
  
  // Store level
  STORE_ADMIN
  SALES_MANAGER
  INVENTORY_MANAGER
  CUSTOMER_SERVICE
  CONTENT_MANAGER
  MARKETING_MANAGER
  DELIVERY_BOY
  
  // Customer level
  CUSTOMER
}

// Project management models
model Project {
  id             String          @id @default(cuid())
  name           String
  description    String?
  slug           String          @unique
  status         String          @default("planning") // planning, active, archived
  organizationId String

  organization   Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  members        ProjectMember[]

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@index([organizationId])
  @@index([slug])
}

model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  role      String   @default("member") // owner, admin, member, viewer

  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([projectId, userId])
  @@index([userId])
}
// ============================================================================
// E-COMMERCE MODELS
// ============================================================================

// E-commerce enums
enum ProductStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

enum OrderStatus {
  PENDING
  PAYMENT_FAILED
  PAID
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  AUTHORIZED
  PAID
  FAILED
  REFUNDED
  DISPUTED
}

enum PaymentMethod {
  CREDIT_CARD
  DEBIT_CARD
  MOBILE_BANKING
  BANK_TRANSFER
  CASH_ON_DELIVERY
}

enum PaymentGateway {
  STRIPE
  SSLCOMMERZ
  MANUAL
}

enum InventoryStatus {
  IN_STOCK
  LOW_STOCK
  OUT_OF_STOCK
  DISCONTINUED
}

enum DiscountType {
  PERCENTAGE
  FIXED
  FREE_SHIPPING
}

enum SubscriptionPlan {
  FREE
  BASIC
  PRO
  ENTERPRISE
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELED
  PAUSED
}

// Store model (E-commerce tenant - extends Organization)
model Store {
  id             String   @id @default(cuid())
  organizationId String   @unique
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  name           String
  slug           String   @unique
  description    String?
  logo           String?
  email          String
  phone          String?
  website        String?
  
  // Address
  address        String?
  city           String?
  state          String?
  postalCode     String?
  country        String   @default("US")
  
  // Settings
  currency       String   @default("USD")
  timezone       String   @default("UTC")
  locale         String   @default("en")
  
  // Subscription
  subscriptionPlan   SubscriptionPlan   @default(FREE)
  subscriptionStatus SubscriptionStatus @default(TRIAL)
  trialEndsAt        DateTime?
  subscriptionEndsAt DateTime?
  
  // Limits
  productLimit   Int      @default(10)
  orderLimit     Int      @default(100)
  
  products       Product[]
  categories     Category[]
  brands         Brand[]
  orders         Order[]
  customers      Customer[]
  attributes     ProductAttribute[]
  auditLogs      AuditLog[]
  inventoryLogs  InventoryLog[] @relation("StoreInventoryLogs")
  staff          StoreStaff[] // Store staff assignments
  
  // Platform management
  platformActivities PlatformActivity[]
  createdFromRequest StoreRequest? @relation("CreatedFromRequest")
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  deletedAt      DateTime?
  
  @@index([slug])
  @@index([subscriptionPlan])
  @@index([subscriptionStatus])
}

// Store staff role assignments (store-level permissions)
model StoreStaff {
  id        String   @id @default(cuid())
  userId    String
  storeId   String
  role      Role     // Store-level roles: STORE_ADMIN, SALES_MANAGER, etc.
  isActive  Boolean  @default(true)
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  store     Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([userId, storeId])
  @@index([storeId, isActive])
  @@index([userId, isActive])
  @@index([storeId, role])
}

// Product models
model Product {
  id          String        @id @default(cuid())
  storeId     String
  store       Store         @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  name        String
  slug        String
  description String?
  shortDescription String?
  
  price       Float
  compareAtPrice Float?
  costPrice   Float?
  
  sku         String
  barcode     String?
  trackInventory Boolean @default(true)
  inventoryQty   Int     @default(0)
  lowStockThreshold Int  @default(5)
  inventoryStatus InventoryStatus @default(IN_STOCK)
  
  weight      Float?
  length      Float?
  width       Float?
  height      Float?
  
  categoryId  String?
  category    Category?     @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  brandId     String?
  brand       Brand?        @relation(fields: [brandId], references: [id], onDelete: SetNull)
  
  images      String        // JSON array of image URLs
  thumbnailUrl String?
  
  metaTitle       String?
  metaDescription String?
  metaKeywords    String?
  seoTitle        String? // Additional SEO title field
  seoDescription  String? // Additional SEO description field
  
  status      ProductStatus @default(DRAFT)
  publishedAt DateTime?
  archivedAt  DateTime? // Soft archiving timestamp
  isFeatured  Boolean       @default(false)
  
  variants    ProductVariant[]
  orderItems  OrderItem[]
  attributes  ProductAttributeValue[]
  reviews     Review[]
  inventoryLogs InventoryLog[] @relation("InventoryLogs")
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  deletedAt   DateTime?
  
  @@unique([storeId, sku])
  @@unique([storeId, slug])
  @@index([storeId, status])
  @@index([storeId, categoryId])
  @@index([storeId, brandId])
  @@index([categoryId, status])
  @@index([brandId, status])
  @@index([storeId, categoryId, status]) // Filtered product lists
  @@index([storeId, createdAt]) // Sorted product lists (newest first)
}

model ProductVariant {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  name      String
  sku       String   @unique
  barcode   String?
  
  price     Float?
  compareAtPrice Float?
  
  inventoryQty Int @default(0)
  lowStockThreshold Int @default(5)
  
  weight    Float?
  image     String?
  options   String   // JSON object of variant options (e.g., {"size": "L", "color": "Red"})
  
  isDefault Boolean  @default(false)
  
  orderItems OrderItem[]
  inventoryLogs InventoryLog[] @relation("VariantInventoryLogs")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([productId])
  @@index([productId, isDefault])
}

model Category {
  id          String   @id @default(cuid())
  storeId     String
  store       Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  name        String
  slug        String
  description String?
  image       String?
  
  parentId    String?
  parent      Category?  @relation("CategoryTree", fields: [parentId], references: [id], onDelete: SetNull)
  children    Category[] @relation("CategoryTree")
  
  metaTitle       String?
  metaDescription String?
  
  isPublished Boolean @default(true)
  sortOrder   Int     @default(0)
  
  products    Product[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?
  
  @@unique([storeId, slug])
  @@index([storeId, parentId])
  @@index([storeId, isPublished])
  @@index([parentId, sortOrder])
  // Note: @@unique([storeId, slug]) already creates an implicit index for lookups
}

model Brand {
  id          String   @id @default(cuid())
  storeId     String
  store       Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  name        String
  slug        String
  description String?
  logo        String?
  website     String?
  
  metaTitle       String?
  metaDescription String?
  
  isPublished Boolean @default(true)
  
  products    Product[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?
  
  @@unique([storeId, slug])
  @@index([storeId, isPublished])
}

model ProductAttribute {
  id        String   @id @default(cuid())
  storeId   String
  store     Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  name      String
  values    String   // JSON array of possible values
  
  productValues ProductAttributeValue[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([storeId, name])
  @@index([storeId])
  // Note: Removed @@index([name]) to prevent cross-tenant queries without storeId
}

model ProductAttributeValue {
  id          String   @id @default(cuid())
  productId   String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  attributeId String
  attribute   ProductAttribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  value       String
  
  createdAt   DateTime @default(now())
  
  @@index([productId, attributeId])
}

// Customer model
model Customer {
  id        String   @id @default(cuid())
  storeId   String
  store     Store    @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  userId    String?  @unique
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  email     String
  firstName String
  lastName  String
  phone     String?
  
  acceptsMarketing Boolean @default(false)
  marketingOptInAt DateTime?
  
  totalOrders       Int     @default(0)
  totalSpent        Float   @default(0)
  averageOrderValue Float   @default(0)
  lastOrderAt       DateTime?
  
  orders    Order[]
  reviews   Review[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  
  @@unique([storeId, email])
  @@index([storeId, userId])
  // Note: @@unique([storeId, email]) already creates an implicit index
  // Removed redundant @@index([storeId, email]) and @@index([email, storeId])
}

// Order models
model Order {
  id        String      @id @default(cuid())
  storeId   String
  store     Store       @relation(fields: [storeId], references: [id], onDelete: Cascade)
  
  customerId String?
  customer   Customer?  @relation(fields: [customerId], references: [id], onDelete: SetNull)
  
  orderNumber String
  status      OrderStatus @default(PENDING)
  
  subtotal        Float
  taxAmount       Float @default(0)
  shippingAmount  Float @default(0)
  discountAmount  Float @default(0)
  totalAmount     Float
  
  discountCode String?
  
  paymentMethod  PaymentMethod?
  paymentGateway PaymentGateway?
  paymentStatus  PaymentStatus @default(PENDING)
  
  shippingMethod String? // Pathao, manual, pickup, etc.
  trackingNumber String?
  trackingUrl    String?
  estimatedDelivery DateTime? // Estimated delivery date
  
  shippingAddress String? // JSON object
  billingAddress  String? // JSON object
  
  fulfilledAt DateTime?
  canceledAt  DateTime?
  cancelReason String?
  
  customerNote String?
  adminNote    String? // Internal notes for staff
  notes        String? // Additional order notes
  
  ipAddress   String?
  
  items    OrderItem[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  
  @@unique([storeId, orderNumber])
  @@index([storeId, customerId])
  @@index([storeId, status])
  @@index([storeId, createdAt])
  // Note: Removed @@index([orderNumber]) to prevent cross-tenant queries
  // Note: Removed @@index([paymentStatus]) to prevent cross-tenant queries
  @@index([storeId, customerId, createdAt]) // Customer order history (tenant-isolated)
  @@index([storeId, status, createdAt]) // Admin dashboard filters
}

model OrderItem {
  id        String   @id @default(cuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)
  variantId String?
  variant   ProductVariant? @relation(fields: [variantId], references: [id], onDelete: SetNull)
  
  productName String
  variantName String?
  sku         String
  image       String?
  
  price       Float
  quantity    Int
  subtotal    Float
  taxAmount   Float @default(0)
  discountAmount Float @default(0)
  totalAmount Float
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([orderId])
  @@index([productId])
}

// Review model
model Review {
  id        String   @id @default(cuid())
  storeId   String
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
  
  rating    Int
  title     String?
  comment   String
  images    String?  // JSON array of image URLs
  
  isApproved Boolean @default(false)
  approvedAt DateTime?
  isVerifiedPurchase Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  
  @@index([storeId, productId])
  @@index([productId, isApproved, createdAt])
  @@index([customerId, createdAt])
}

// Inventory log model (for audit trail)
model InventoryLog {
  id          String   @id @default(cuid())
  storeId     String
  store       Store    @relation("StoreInventoryLogs", fields: [storeId], references: [id], onDelete: Cascade)
  productId   String
  product     Product  @relation("InventoryLogs", fields: [productId], references: [id], onDelete: Cascade)
  variantId   String?
  variant     ProductVariant? @relation("VariantInventoryLogs", fields: [variantId], references: [id], onDelete: SetNull)
  orderId     String?
  
  previousQty Int
  newQty      Int
  changeQty   Int
  reason      String   // String value from InventoryAdjustmentReason enum (stored as raw string, not TypeScript enum)
  note        String?
  
  userId      String?
  user        User?    @relation("InventoryUserLogs", fields: [userId], references: [id], onDelete: SetNull)
  
  createdAt   DateTime @default(now())
  
  @@index([storeId, productId, createdAt])
  @@index([productId, createdAt])
  @@index([variantId, createdAt])
  @@index([orderId])
  @@index([userId, createdAt])
  @@index([reason])
}

// Audit log model (for tracking all system actions)
model AuditLog {
  id        String   @id @default(cuid())
  storeId   String?
  store     Store?   @relation(fields: [storeId], references: [id], onDelete: Cascade)

  userId    String?
  user      User?    @relation("AuditUserLogs", fields: [userId], references: [id], onDelete: SetNull)

  action    String   // e.g., "CREATE", "UPDATE", "DELETE"
  entityType String  // e.g., "Product", "Order", "User"
  entityId  String
  
  // Permission tracking
  permission String?  // Permission being checked (e.g., "products:create")
  role       String?  // User's role at time of action
  allowed    Int?     // Permission check result (1 = allowed, 0 = denied)
  
  // Request metadata
  endpoint   String?  // API endpoint called
  method     String?  // HTTP method (GET, POST, etc.)
  ipAddress  String?
  userAgent  String?
  
  // Change tracking
  changes   String?  // JSON { "field": { "old": "value", "new": "value" } }

  createdAt DateTime @default(now())

  @@index([storeId, createdAt])
  @@index([userId, createdAt])
  @@index([entityType, entityId, createdAt])
  @@index([permission, allowed, createdAt])
  @@index([userId, action, createdAt])
  @@map("audit_logs")
}

// Rate limiting tracking
model RateLimit {
  id         String   @id @default(cuid())
  identifier String   // userId or IP address
  endpoint   String   // API endpoint pattern
  role       String?  // User's role (for role-based limits)
  
  // Counters
  requestCount Int     @default(1)
  windowStart  DateTime @default(now())
  
  // Metadata
  lastRequest  DateTime @default(now())
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([identifier, endpoint, windowStart])
  @@index([identifier, endpoint, windowStart])
  @@index([windowStart])
  @@map("rate_limits")
}

// ============================================================================
// NOTIFICATION & PLATFORM MANAGEMENT MODELS
// ============================================================================

// Notification types enum
enum NotificationType {
  ACCOUNT_PENDING        // Account awaiting approval
  ACCOUNT_APPROVED       // Account approved by admin
  ACCOUNT_REJECTED       // Account rejected by admin
  ACCOUNT_SUSPENDED      // Account suspended
  STORE_CREATED          // Store created for user
  STORE_ASSIGNED         // User assigned to store
  STORE_REQUEST_PENDING  // Admin notification: new store request
  STORE_REQUEST_APPROVED // Store request approved
  STORE_REQUEST_REJECTED // Store request rejected
  PASSWORD_RESET         // Password reset requested
  SECURITY_ALERT         // Security-related notification
  SYSTEM_ANNOUNCEMENT    // Platform-wide announcement
  NEW_USER_REGISTERED    // Admin notification: new user signup
  STORE_REQUEST          // Admin notification: store request
}

// User notifications
model Notification {
  id        String           @id @default(cuid())
  
  userId    String
  user      User             @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  
  type      NotificationType
  title     String
  message   String
  data      String?          // JSON data for additional context
  
  read      Boolean          @default(false)
  readAt    DateTime?
  
  // Action tracking
  actionUrl   String?        // URL to navigate when clicked
  actionLabel String?        // Button label for action
  
  createdAt DateTime         @default(now())
  
  @@index([userId, read, createdAt])
  @@index([userId, type, createdAt])
  @@index([createdAt])
  @@map("notifications")
}

// Platform activity log (Super Admin monitoring)
model PlatformActivity {
  id          String   @id @default(cuid())
  
  actorId     String?  // User who performed the action (null for system)
  actor       User?    @relation("PlatformActivityActor", fields: [actorId], references: [id], onDelete: SetNull)
  
  targetUserId String? // User affected by the action
  targetUser   User?   @relation("PlatformActivityTarget", fields: [targetUserId], references: [id], onDelete: SetNull)
  
  storeId     String?  // Store involved (if any)
  store       Store?   @relation(fields: [storeId], references: [id], onDelete: SetNull)
  
  action      String   // e.g., "USER_REGISTERED", "USER_APPROVED", "STORE_CREATED"
  entityType  String   // e.g., "User", "Store", "StoreUser"
  entityId    String?
  
  description String   // Human-readable description
  metadata    String?  // JSON additional data
  
  ipAddress   String?
  userAgent   String?
  
  createdAt   DateTime @default(now())
  
  @@index([actorId, createdAt])
  @@index([targetUserId, createdAt])
  @@index([storeId, createdAt])
  @@index([action, createdAt])
  @@index([createdAt])
  @@map("platform_activities")
}

// Store creation requests (user-initiated)
model StoreRequest {
  id            String   @id @default(cuid())
  
  userId        String
  user          User     @relation("UserStoreRequests", fields: [userId], references: [id], onDelete: Cascade)
  
  // Requested store details
  storeName     String
  storeSlug     String?
  storeDescription String?
  
  // Business information
  businessName    String?
  businessCategory String?
  businessAddress String?
  businessPhone   String?
  businessEmail   String?
  
  // Request status
  status        String   @default("PENDING") // PENDING, APPROVED, REJECTED
  
  // Admin response
  reviewedBy    String?
  reviewer      User?    @relation("StoreRequestReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)
  reviewedAt    DateTime?
  rejectionReason String?
  
  // If approved, link to created store
  createdStoreId String?  @unique
  createdStore   Store?   @relation("CreatedFromRequest", fields: [createdStoreId], references: [id], onDelete: SetNull)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([userId, status])
  @@index([status, createdAt])
  @@index([reviewedBy])
  @@map("store_requests")
}